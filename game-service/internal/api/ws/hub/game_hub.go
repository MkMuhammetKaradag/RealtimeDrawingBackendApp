package hub

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/google/uuid"
)

// GameState, oyunun hangi a≈üamada olduƒüunu g√∂steren sabitler.
const (
	GameStateInProgress = "in_progress"
	GameStateOver       = "over"
)

// IGameEngine, t√ºm oyun motorlarƒ± i√ßin ortak bir aray√ºz tanƒ±mlar.

type IGameEngine interface {
	InitGame(game *Game, players []*Player) error
	ProcessMove(game *Game, playerID uuid.UUID, moveData interface{}) error
	StartRound(game *Game) error
	EndRound(game *Game, reason string) bool
	// Sadece bildirim g√∂nderme gibi genel yardƒ±mcƒ± metotlar aray√ºze eklenebilir.
	SendPreparationNotifications(game *Game)
}

// Player, oyundaki bir oyuncuyu temsil eder.
type Player struct {
	UserID      uuid.UUID
	Username    string
	Score       int
	IsConnected bool
	// Oyuncuya √∂zg√º diƒüer veriler
}

type GameSettings struct {
	ModeName            string `json:"mode_name"`
	ModeID              string `json:"mode_id"`
	TotalRounds         int    `json:"total_rounds"`
	RoundDuration       int    `json:"round_duration"` // saniye cinsinden
	PreparationDuration int    `json:"preparation_duration"`
	MaxPlayers          int    `json:"max_players"`
	MinPlayers          int    `json:"min_players"`
}

// Game, bir oyunun mevcut durumunu tutar.
type Game struct {
	RoomID              uuid.UUID   `json:"room_id"`
	ModeName            string      `json:"mode_name"`
	ModeID              string      `json:"mode_id"`
	State               string      `json:"state"`
	Players             []*Player   `json:"players"`
	TurnCount           int         `json:"turn_count"`
	TotalRounds         int         `json:"total_rounds"`
	RoundDuration       int         `json:"round_duration"`
	ActivePlayer        uuid.UUID   `json:"active_player"`
	LastMoveTime        time.Time   `json:"last_move_time"`
	PreparationDuration int         `json:"preparation_duration"` // üéØ YENƒ∞
	ModeData            interface{} `json:"mode_data"`
	CurrentDrawerIndex  int         `json:"current_drawer_index"`
	Mutex               sync.RWMutex
}

type CommonAreaGameData struct {
	CanvasData string
}

// GameHub, oyunun i≈ü mantƒ±ƒüƒ±ndan sorumludur.
type GameHub struct {
	hub *Hub
	// roomID -> game nesnesi
	activeGames map[uuid.UUID]*Game
	// gameModeName -> IGameEngine aray√ºz√º
	gameEngines     map[string]IGameEngine
	roomSettings    map[uuid.UUID]*GameSettings
	roundTimers     map[uuid.UUID]context.CancelFunc
	timerWaitGroups map[uuid.UUID]*sync.WaitGroup
	roundEndSignal  chan RoundEndSignal

	mutex sync.RWMutex
}
type RoundEndSignal struct {
	RoomID uuid.UUID
	Reason string
}

func NewGameHub(hub *Hub) *GameHub {
	gameHub := &GameHub{
		hub:             hub,
		activeGames:     make(map[uuid.UUID]*Game),
		roomSettings:    make(map[uuid.UUID]*GameSettings),
		gameEngines:     make(map[string]IGameEngine),
		roundTimers:     make(map[uuid.UUID]context.CancelFunc),
		timerWaitGroups: make(map[uuid.UUID]*sync.WaitGroup),
		roundEndSignal:  make(chan RoundEndSignal, 5),
	}

	// gameHub.gameEngines["√áizim ve Tahmin"] = NewDrawingGameEngine(gameHub)
	gameHub.gameEngines["1"] = NewDrawingGameEngine(gameHub)
	gameHub.gameEngines["2"] = NewCollaborativeArtEngine(gameHub)
	// gameHub.gameEngines["Ortak Alan"] = NewDrawingGameEngine(gameHub)
	// gameHub.gameEngines["serbest √ßizim"] = NewDrawingGameEngine(gameHub)
	go gameHub.RunListener()
	return gameHub
}

func (gh *GameHub) GetActiveGame(roomID uuid.UUID) *Game {
	gh.mutex.RLock()
	defer gh.mutex.RUnlock()
	return gh.activeGames[roomID]
}
func (g *GameHub) RunListener() {
	for {
		select {
		case quit := <-g.hub.playerQuit: // (√ñnceki i≈ülevsellik)
			log.Printf("RUN_LISTENER: Player quit received - Room: %s, User: %s\n", quit.RoomID, quit.UserID)
			g.HandlePlayerQuit(quit.RoomID, quit.UserID)

		// üí° YENƒ∞ CASE: Tur biti≈ü sinyalini i≈üle
		case endSignal := <-g.roundEndSignal:
			// Sinyal geldiƒüinde, G√úVENLƒ∞ bir ≈üekilde handleRoundEnd'i √ßaƒüƒ±r.
			// Bu zaten bir Gorutin i√ßinde olduƒüu i√ßin kilitlenme riski d√º≈ü√ºkt√ºr.
			log.Printf("RUN_LISTENER: Round end signal received for room %s. Reason: %s", endSignal.RoomID, endSignal.Reason)
			g.handleRoundEnd(endSignal.RoomID, endSignal.Reason)
		}
	}
}
func (g *GameHub) HandlePlayerQuit(roomID uuid.UUID, userID uuid.UUID) {
	log.Printf("HandlePlayerQuit called for room %s, user %s", roomID, userID)

	g.mutex.Lock()

	game, exists := g.activeGames[roomID]
	if !exists || game.State != GameStateInProgress {
		g.mutex.Unlock()
		log.Printf("No active game found for room %s", roomID)
		return
	}

	// üîç Oyuncuyu bul
	var targetPlayer *Player
	for _, p := range game.Players {
		if p.UserID == userID {
			targetPlayer = p
			break
		}
	}

	if targetPlayer == nil {
		g.mutex.Unlock()
		log.Printf("Player %s not found in game", userID)
		return
	}

	// Oyun ayarlarƒ±nƒ± kontrol et
	settings, settingsExist := g.roomSettings[roomID]
	if !settingsExist {
		g.mutex.Unlock()
		log.Printf("WARNING: Room settings not found for room %s", roomID)
		return
	}

	// Ayrƒ±lan oyuncu aktif √ßizen miydi?
	wasActiveDrawer := game.ActivePlayer == userID

	g.mutex.Unlock()

	// üÜï Reconnect i√ßin grace period (30 saniye) ba≈ülat
	go g.handleDisconnectWithGracePeriod(roomID, userID, wasActiveDrawer, settings.MinPlayers)
	// // Oyuncu listesinden √ßƒ±kar
	// newPlayers := make([]*Player, 0, len(game.Players)-1)
	// playerFound := false
	// var removedPlayer *Player

	// for _, p := range game.Players {
	// 	if p.UserID == userID {
	// 		playerFound = true
	// 		removedPlayer = p
	// 		continue
	// 	}
	// 	newPlayers = append(newPlayers, p)
	// }

	// if !playerFound {
	// 	g.mutex.Unlock()
	// 	log.Printf("Player %s not found in game", userID)
	// 	return
	// }

	// // Oyuncu listesini g√ºncelle
	// game.Players = newPlayers
	// remainingPlayerCount := len(game.Players)

	// log.Printf("Player %s removed. Remaining players: %d", userID, remainingPlayerCount)

	// // Oyun ayarlarƒ±nƒ± kontrol et
	// settings, settingsExist := g.roomSettings[roomID]
	// if !settingsExist {
	// 	g.mutex.Unlock()
	// 	log.Printf("WARNING: Room settings not found for room %s", roomID)
	// 	return
	// }

	// // Ayrƒ±lan oyuncu aktif √ßizen miydi?
	// wasActiveDrawer := game.ActivePlayer == userID

	// // üî• √ñNEMLƒ∞: Mutex'i burada unlock et - √ß√ºnk√º a≈üaƒüƒ±daki i≈ülemler lock gerektiriyor
	// g.mutex.Unlock()

	// // Kalan oyuncu sayƒ±sƒ± minimum sayƒ±sƒ±ndan az mƒ±?
	// if remainingPlayerCount < settings.MinPlayers {
	// 	log.Printf("Insufficient players (%d < %d). Ending game for room %s",
	// 		remainingPlayerCount, settings.MinPlayers, roomID)

	// 	// Zamanlayƒ±cƒ±yƒ± durdur
	// 	g.stopRoundTimer(roomID)

	// 	// Oyunu bitir
	// 	g.handleEndGame(roomID, RoomManagerData{
	// 		Type: "end_game",
	// 		Content: map[string]interface{}{
	// 			"room_id": roomID,
	// 			"reason":  "insufficient_players",
	// 			"message": fmt.Sprintf("Oyun sonlandƒ±rƒ±ldƒ±. Minimum %d oyuncu gerekli.", settings.MinPlayers),
	// 		},
	// 	})
	// 	return
	// }

	// // Oyunculara ayrƒ±lma bildirimini g√∂nder
	// g.hub.BroadcastMessage(roomID, &Message{
	// 	Type: "player_left",
	// 	Content: map[string]interface{}{
	// 		"room_id":       roomID,
	// 		"user_id":       userID,
	// 		"username":      removedPlayer.Username,
	// 		"remaining":     remainingPlayerCount,
	// 		"active_drawer": wasActiveDrawer,
	// 	},
	// })

	// // Eƒüer ayrƒ±lan oyuncu √ßizen ise, turu bitir
	// if wasActiveDrawer {
	// 	log.Printf("Active drawer %s left. Ending round for room %s", userID, roomID)

	// 	// üí° NON-BLOCKING ≈üekilde roundEndSignal g√∂nder
	// 	select {
	// 	case g.roundEndSignal <- RoundEndSignal{
	// 		RoomID: roomID,
	// 		Reason: "drawer_left",
	// 	}:
	// 		log.Printf("Round end signal sent for room %s", roomID)
	// 	default:
	// 		log.Printf("WARNING: roundEndSignal channel full, calling handleRoundEnd directly")
	// 		g.handleRoundEnd(roomID, "drawer_left")
	// 	}
	// }
}

func (g *GameHub) handleDisconnectWithGracePeriod(roomID, userID uuid.UUID, wasActiveDrawer bool, minPlayers int) {
	gracePeriod := 30 * time.Second
	log.Printf("Starting grace period (%v) for player %s in room %s", gracePeriod, userID, roomID)

	// Grace period s√ºresi boyunca bekle
	timer := time.NewTimer(gracePeriod)
	defer timer.Stop()

	<-timer.C

	// S√ºre doldu, oyuncu hala baƒülanmadƒ± mƒ± kontrol et
	g.mutex.Lock()
	game, exists := g.activeGames[roomID]
	if !exists || game.State != GameStateInProgress {
		g.mutex.Unlock()
		log.Printf("Game no longer active for room %s", roomID)
		return
	}

	// üîç Oyuncu hala oyunda mƒ± ve baƒülƒ± deƒüil mi?
	playerStillDisconnected := false
	var removedPlayer *Player
	newPlayers := make([]*Player, 0, len(game.Players)-1)

	for _, p := range game.Players {
		if p.UserID == userID {
			// Hub'dan kontrol et - oyuncu yeniden baƒülandƒ± mƒ±?
			if g.hub.IsClientConnected(roomID, userID) {
				log.Printf("Player %s reconnected within grace period, keeping in game", userID)
				g.mutex.Unlock()
				return
			}
			playerStillDisconnected = true
			removedPlayer = p
			continue
		}
		newPlayers = append(newPlayers, p)
	}

	if !playerStillDisconnected {
		g.mutex.Unlock()
		log.Printf("Player %s not found or already removed from game", userID)
		return
	}

	// Oyuncuyu listeden √ßƒ±kar
	game.Players = newPlayers
	remainingPlayerCount := len(game.Players)

	log.Printf("Grace period expired. Player %s removed. Remaining players: %d", userID, remainingPlayerCount)

	g.mutex.Unlock()

	// Kalan oyuncu sayƒ±sƒ± yetersiz mi?
	if remainingPlayerCount < minPlayers {
		log.Printf("Insufficient players (%d < %d). Ending game for room %s",
			remainingPlayerCount, minPlayers, roomID)

		g.stopRoundTimer(roomID)
		g.handleEndGame(roomID, RoomManagerData{
			Type: "end_game",
			Content: map[string]interface{}{
				"room_id": roomID,
				"reason":  "insufficient_players",
				"message": fmt.Sprintf("Oyun sonlandƒ±rƒ±ldƒ±. Minimum %d oyuncu gerekli.", minPlayers),
			},
		})
		return
	}

	// Oyunculara ayrƒ±lma bildirimini g√∂nder
	g.hub.BroadcastMessage(roomID, &Message{
		Type: "player_left",
		Content: map[string]interface{}{
			"room_id":       roomID,
			"user_id":       userID,
			"username":      removedPlayer.Username,
			"remaining":     remainingPlayerCount,
			"active_drawer": wasActiveDrawer,
		},
	})

	if wasActiveDrawer {
		log.Printf("Active drawer %s left. Ending round for room %s", userID, roomID)

		// üí° NON-BLOCKING ≈üekilde roundEndSignal g√∂nder
		select {
		case g.roundEndSignal <- RoundEndSignal{
			RoomID: roomID,
			Reason: "drawer_left",
		}:
			log.Printf("Round end signal sent for room %s", roomID)
		default:
			log.Printf("WARNING: roundEndSignal channel full, calling handleRoundEnd directly")
			g.handleRoundEnd(roomID, "drawer_left")
		}
	}
}
func (g *GameHub) startRoundTimer(roomID uuid.UUID, duration time.Duration) {
	// √ñnceki zamanlayƒ±cƒ± varsa durdur ve bekle (Bloklama burada oluyor)
	g.stopRoundTimer(roomID)

	// Yeni zamanlayƒ±cƒ± i√ßin hazƒ±rlƒ±k
	wg := &sync.WaitGroup{}
	wg.Add(1)

	// üí° DEƒûƒ∞≈ûƒ∞KLƒ∞K: context.WithCancel yerine context.WithTimeout kullanƒ±n!
	ctx, cancel := context.WithTimeout(context.Background(), duration)

	// Haritalara kaydet
	g.mutex.Lock()
	g.roundTimers[roomID] = cancel
	g.timerWaitGroups[roomID] = wg
	g.mutex.Unlock()
	log.Printf("START_TIMER: Goroutine started for room %s, duration: %v", roomID, duration)
	go func() {
		defer wg.Done() // Gorutin i≈üini bitirdiƒüinde sayacƒ± azalt.

		select {
		case <-ctx.Done():
			// Context, ya s√ºre dolduƒüu i√ßin (Timeout) ya da manuel iptal (Cancel)
			// nedeniyle kapandƒ±.
			log.Printf("TIMER_GOROUTINE: Context closed for room %s. Error: %v", roomID, ctx.Err())
			// üí° Kontrol: S√ºre mi doldu, yoksa iptal mi edildi?
			if ctx.Err() == context.DeadlineExceeded {
				g.roundEndSignal <- struct {
					RoomID uuid.UUID
					Reason string
				}{
					RoomID: roomID,
					Reason: "time_expired",
				}
			}
			// (context.Canceled ise, manuel bitmi≈ütir ve bu zaten EndRound'ƒ± tetiklemi≈ütir.)
			return
		}
	}()
}

// package hub
func (g *GameHub) stopRoundTimer(roomID uuid.UUID) {
	var cancelFunc context.CancelFunc
	var wg *sync.WaitGroup
	var cancelExists, wgExists bool

	// 1. Lock/Unlock ve Haritalardan Kaldƒ±rma
	g.mutex.Lock()
	cancelFunc, cancelExists = g.roundTimers[roomID]
	wg, wgExists = g.timerWaitGroups[roomID]

	delete(g.roundTimers, roomID)
	delete(g.timerWaitGroups, roomID)
	g.mutex.Unlock() // Kilit serbest bƒ±rakƒ±ldƒ±.

	// 2. ƒ∞ptal Sinyalini G√∂nder
	if cancelExists {
		cancelFunc()
		log.Printf("STOP_TIMER: Cancel signal sent for room %s.", roomID)
	}

	// 3. Goroutine'in Bitmesini G√úVENLƒ∞ Bƒ∞R ≈ûEKƒ∞LDE Bekle (Zaman A≈üƒ±mƒ±)
	if wgExists {
		done := make(chan struct{})

		// Goroutine'i bekleyen AYRI bir Goroutine ba≈ülat
		go func() {
			// √ñNEMLƒ∞: Eƒüer timer Goroutine'de birden fazla wg.Done() varsa
			// veya hi√ß yoksa, bu kilitlenir. Ancak timeout bunu √ß√∂zer.
			wg.Wait()
			close(done)
		}()

		// Zaman a≈üƒ±mƒ± ile bekle
		select {
		case <-done:
			// Ba≈üarƒ±lƒ±: Goroutine sonlandƒ±.
			log.Printf("STOP_TIMER: Old timer for %s safely stopped.", roomID)
		case <-time.After(500 * time.Millisecond): // 0.5 saniye yeterli olmalƒ±
			// Zaman A≈üƒ±mƒ±: 0.5 saniye i√ßinde sonlanmadƒ±, ancak devam et.
			log.Printf("STOP_TIMER: WARNING: Old timer for %s did not terminate in 500ms. Continuing.", roomID)
		}
	}
}

func (g *GameHub) handleRoundEnd(roomID uuid.UUID, reason string) {
	// 1. En √ºst seviye kilit: GameHub'ƒ± kilitliyoruz.

	log.Printf("HANDLE_ROUND_END: Starting round end process for room %s. Reason: %s", roomID, reason)
	// 2. Zamanlayƒ±cƒ±yƒ± hemen durdur.
	g.stopRoundTimer(roomID)
	g.mutex.Lock()
	defer g.mutex.Unlock()
	fmt.Println("Round timer stopped for room", roomID)

	game, exists := g.activeGames[roomID]
	if !exists {
		return // Oyun zaten bitmi≈ü olabilir
	}
	log.Printf("Round ended for room %s. Reason: %s", roomID, reason)

	engine, ok := g.gameEngines[game.ModeID]
	if !ok {
		log.Printf("Game engine not found for mode: %s", game.ModeID)
		return
	}
	// dge, _ := engine.(*DrawingGameEngine)
	log.Printf("HANDLE_ROUND_END: Attempting to acquire game.Mutex for room %s.", roomID)
	// 3. Oyun durumunu g√ºncellemek i√ßin Game kilidini alƒ±yoruz.
	game.Mutex.Lock()

	// dge.EndRound metodu, puanlama ve tur/oyun biti≈ü kontrol√ºn√º yapar.
	// Artƒ±k bu metodun i√ßinde kilit yok.
	shouldContinue := engine.EndRound(game, reason)

	// Game kilidini serbest bƒ±rak (√ßok √∂nemli!).
	game.Mutex.Unlock()
	log.Printf("HANDLE_ROUND_END: EndRound finished for room %s. Should continue: %v", roomID, shouldContinue)
	gameSnapshot := *game
	var cleanModeData interface{}
	if game.ModeID == "2" {
		artData, ok := game.ModeData.(*CollaborativeArtData)
		if ok {
			// RoundHistory'si olmayan yeni bir CollaborativeArtData olu≈ütur.
			cleanModeData = &CollaborativeArtData{
				CurrentWord:    artData.CurrentWord,
				CurrentStrokes: artData.CurrentStrokes, // Bu zaten bo≈ü olmalƒ±
				RoundHistory:   nil,                    // üîë √ñNEMLƒ∞: Ge√ßmi≈üi g√∂nderme!
			}
			gameSnapshot.ModeData = cleanModeData
		}
	}
	// 4. Her tur bittiƒüinde oyunculara genel bir "tur bitti" mesajƒ± yayƒ±nla.
	g.hub.BroadcastMessage(roomID, &Message{
		Type: "round_ended",
		Content: map[string]interface{}{
			"room_id": roomID,
			"reason":  reason,
			"game":    gameSnapshot, // G√ºncel oyun durumunu g√∂nder
		},
	})

	// 5. Bir sonraki tura ge√ßilecek mi, yoksa oyun mu bitecek kararƒ±nƒ± ver.
	if shouldContinue {
		// Yeni tur varsa:
		log.Printf("NEXT_ROUND: Starting in background for room %s.", roomID)
		// Yeniden Game kilidini alƒ±yoruz, √ß√ºnk√º StartRound oyun nesnesini deƒüi≈ütirecek.
		// ‚ö†Ô∏è KRƒ∞Tƒ∞K DEƒûƒ∞≈ûƒ∞KLƒ∞K: StartRound ve Timer'ƒ± yeni bir Goroutine'e ta≈üƒ±!
		go func(g *GameHub, engine IGameEngine, game *Game, roomID uuid.UUID) {
			preparationDuration := time.Duration(game.PreparationDuration) * time.Second

			game.Mutex.Lock()
			engine.SendPreparationNotifications(game)
			game.Mutex.Unlock()

			log.Printf("PREPARATION: Waiting %v seconds before starting round for room %s",
				game.PreparationDuration, roomID)

			// 2. HAZIRLIK S√úRESƒ∞Nƒ∞ BEKLE
			time.Sleep(preparationDuration)
			// Yeni turu ba≈ülat (Game kilidi GOROUTINE i√ßinde alƒ±nmalƒ±!)
			game.Mutex.Lock()

			if err := engine.StartRound(game); err != nil {
				log.Printf("GOROUTINE ERROR: Error starting next round: %v", err)
			}

			game.Mutex.Unlock()

			// Yeni tur zamanlayƒ±cƒ±sƒ±nƒ± ba≈ülat.
			duration := time.Duration(game.RoundDuration) * time.Second
			g.startRoundTimer(roomID, duration)

		}(g, engine, game, roomID) // Deƒüi≈ükenleri Goroutine'e ge√ßir.

		log.Printf("NEXT_ROUND: Starting in background for room %s.", roomID)

	} else {
		// üö® OYUN Bƒ∞TTƒ∞YSE: Moda √∂zel sonlandƒ±rma ve raporlama.
		log.Printf("GAME_OVER: Game finished for room %s. Mode: %s", roomID, game.ModeID)

		gameOverContent := make(map[string]interface{})
		gameOverContent["scores"] = game.Players // Skorlarƒ± her zaman g√∂ndermek k√∂t√º deƒüil.
		gameOverContent["data"] = game.ModeData

		// üéØ KRƒ∞Tƒ∞K DEƒûƒ∞≈ûƒ∞KLƒ∞K: Sadece DrawingGameEngine gibi puanlamalƒ± modlar i√ßin kazananƒ± belirle.
		if game.ModeID == "1" {
			// Motoru somut tipine d√∂n√º≈üt√ºrmemiz GEREKƒ∞YOR, √ß√ºnk√º determineWinner IGameEngine'de yok.
			// Bu, aray√ºz√ºn zayƒ±flƒ±ƒüƒ±dƒ±r, ancak puanlamasƒ±z modlarƒ± desteklemek i√ßin gerekli bir tavizdir.
			dge, ok := engine.(*DrawingGameEngine)
			if ok {
				gameOverContent["winner"] = dge.determineWinner(game)
				dge.SendFinalArtReport(game)
			}
		} else if game.ModeID == "2" {
			// CollaborativeArtEngine'e √∂zel bir "Oyun Bitti" aksiyonu varsa √ßaƒüƒ±r.
			// √ñrneƒüin, √∂nceden tanƒ±mladƒ±ƒüƒ±nƒ±z SendFinalArtReport metodu buraya gelir.
			// Not: Bu √ßaƒürƒ± zaten EndRound i√ßinde de yapƒ±lƒ±yor olabilir, kontrol edin.
			// Eƒüer SendFinalArtReport √ßaƒürƒ±sƒ± EndRound i√ßinde yapƒ±lmƒ±yorsa:
			// cae, ok := engine.(*CollaborativeArtEngine)
			// if ok { cae.SendFinalArtReport(game) }
			cae, ok := engine.(*CollaborativeArtEngine)
			if ok {
				// Bu, RoundHistory'yi toplayƒ±p √∂zel bir 'game_over_report' mesajƒ± yayƒ±nlar.
				cae.SendFinalArtReport(game)
			}
			// Ortak Sanat Projesinde kazanan yerine sadece final rapor bilgisi g√∂nderilir.
			gameOverContent["message"] = "Ortak Sanat Projesi Tamamlandƒ±. L√ºtfen Raporu kontrol edin."

		}

		// Oyun Bitti mesajƒ±nƒ± yayƒ±nla.
		// g.hub.BroadcastMessage(game.RoomID, &Message{
		// 	Type:    "game_over",
		// 	Content: gameOverContent,
		// })

		// Aktif oyunlardan kaldƒ±r.
		delete(g.activeGames, roomID)
		// delete(g.roomSettings, roomID)
	}
}
func (g *GameHub) HandleGameMessage(roomID uuid.UUID, msg RoomManagerData) {
	// g.mutex.Lock()
	// defer g.mutex.Unlock()

	fmt.Println("GameHub'da gelen mesaj:", msg.Type, "RoomID:", roomID)

	switch msg.Type {
	case "game_mode_change":
		g.handleGameModeChange(roomID, msg)
	case "game_settings_update":
		g.handleGameSettingsUpdate(roomID, msg)
	case "game_started":
		g.handleGameStarted(roomID, msg)
	case "player_move":
		g.handlePlayerMove(roomID, msg)
	case "canvas_action":
		g.handlePlayerMove(roomID, msg)

	default:
		fmt.Printf("GameHub: Bilinmeyen mesaj tipi: %s\n", msg.Type)
	}
}

// handleGameModeChange, oyun modu deƒüi≈üikliƒüini i≈üler
func (g *GameHub) handleGameModeChange(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun modu deƒüi≈üikliƒüi - Room: %s\n", roomID)

	modeData, ok := msg.Content.(map[string]interface{})
	if !ok {
		fmt.Println("Game mode verisi parse edilemedi")
		return
	}
	fmt.Printf("Oyun modu deƒüi≈üikliƒüi - data : %s\n", modeData)

	modeID, ok := modeData["mode_id"].(string)
	if !ok {
		fmt.Println("Mode id  bulunamadƒ±")
		return
	}

	// Oyun motoru var mƒ± kontrol et
	if _, exists := g.gameEngines[modeID]; !exists {
		fmt.Printf("Desteklenmeyen oyun modu: %s\n", modeID)
		return
	}

	// Odanƒ±n ayarlarƒ±nƒ± al veya olu≈ütur
	settings, exists := g.roomSettings[roomID]
	if !exists {
		settings = g.getDefaultSettings(modeID)
		settings.ModeID = modeID
		settings.ModeName = modeData["mode_name"].(string)
	} else {
		settings.ModeID = modeID
		// Mode deƒüi≈ütiƒüinde ayarlarƒ± yeniden hesapla
		// g.calculateGameSettings(roomID, settings)
	}

	g.roomSettings[roomID] = settings

	// Oyun modu deƒüi≈üikliƒüini odadaki herkese bildir
	response := &Message{
		Type: "game_mode_changed",
		Content: map[string]interface{}{
			"room_id":      roomID,
			"game_mode_id": modeID,
		},
	}

	g.hub.BroadcastMessage(roomID, response)
	fmt.Printf("Oyun modu deƒüi≈ütirildi - Room: %s, Mode: %s\n", roomID, modeID)
}

// handleGameSettingsUpdate, oyun ayarlarƒ± g√ºncellemesini i≈üler
func (g *GameHub) handleGameSettingsUpdate(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun ayarlarƒ± g√ºncelleniyor - Room: %s\n", roomID)

	settingsData, ok := msg.Content.(map[string]interface{})
	if !ok {
		fmt.Println("Settings verisi parse edilemedi")
		return
	}

	settings, exists := g.roomSettings[roomID]
	if !exists {
		// Varsayƒ±lan ayarlarƒ± olu≈ütur
		settings = &GameSettings{
			ModeName:            "√áizim ve Tahmin", // default
			ModeID:              "1",
			TotalRounds:         2,
			RoundDuration:       60,
			PreparationDuration: 5, // üéØ Varsayƒ±lan 5 saniye
			MaxPlayers:          8,
			MinPlayers:          2,
		}
	}

	// Ayarlarƒ± g√ºncelle
	if rounds, ok := settingsData["total_rounds"].(float64); ok {
		settings.TotalRounds = int(rounds)
	}
	if duration, ok := settingsData["round_duration"].(float64); ok {
		settings.RoundDuration = int(duration)
	}
	if maxPlayers, ok := settingsData["max_players"].(float64); ok {
		settings.MaxPlayers = int(maxPlayers)
	}
	if minPlayers, ok := settingsData["min_players"].(float64); ok {
		settings.MinPlayers = int(minPlayers)
	}

	g.roomSettings[roomID] = settings

	// Ayar g√ºncellemesini bildir
	response := &Message{
		Type: "game_settings_updated",
		Content: map[string]interface{}{
			"max_players":    settings.MaxPlayers,
			"min_players":    settings.MinPlayers,
			"game_mode_id":   settings.ModeID,
			"mode_name":      settings.ModeName,
			"total_rounds":   settings.TotalRounds,
			"round_duration": settings.RoundDuration,
		},
	}

	g.hub.BroadcastMessage(roomID, response)
	fmt.Printf("Oyun ayarlarƒ± g√ºncellendi - Room: %s\n", roomID)
}

// handleGameStarted, oyun ba≈ülatƒ±ldƒ±ƒüƒ±nda √ßaƒürƒ±lƒ±r
func (g *GameHub) handleGameStarted(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun ba≈ülatƒ±lƒ±yor - Room: %s\n", roomID)

	g.mutex.RLock()
	game, gameExists := g.activeGames[roomID]
	settings, settingsExists := g.roomSettings[roomID]
	g.mutex.RUnlock() // üõë Okuma bitti, GameHub kilidini serbest bƒ±rak!

	if gameExists && game.State == GameStateInProgress {
		fmt.Printf("Oyun zaten devam ediyor. Yeni oyun ba≈ülatma isteƒüi reddedildi - Room: %s\n", roomID)
		// Oyunculara hata mesajƒ± g√∂nder

		g.hub.BroadcastMessage(roomID, &Message{
			Type: "game_start_failed",
			Content: map[string]interface{}{
				"room_id": roomID,
				"reason":  "game_already_in_progress",
				"message": "Bu odada zaten bir oyun devam ediyor.",
			},
		})
		return
	}

	if !settingsExists {
		fmt.Printf("Oda ayarlarƒ± bulunamadƒ±, varsayƒ±lan ayarlar kullanƒ±lƒ±yor - Room: %s\n", roomID)
		settings = g.getDefaultSettings("√áizim ve Tahmin")

	}

	// Odadaki oyuncu sayƒ±sƒ±nƒ± kontrol et
	playerCount := g.hub.GetRoomClientCount(roomID)
	if playerCount < settings.MinPlayers {
		fmt.Printf("Yetersiz oyuncu sayƒ±sƒ± - Room: %s, Mevcut: %d, Minimum: %d\n",
			roomID, playerCount, settings.MinPlayers)

		// Yetersiz oyuncu mesajƒ± g√∂nder
		response := &Message{
			Type: "game_start_failed",
			Content: map[string]interface{}{
				"room_id": roomID,
				"reason":  "insufficient_players",
				"message": fmt.Sprintf("Minimum %d oyuncu gerekli", settings.MinPlayers),
			},
		}
		g.hub.BroadcastMessage(roomID, response)
		return
	}

	// Odadaki oyuncularƒ± al (Bu fonksiyonu Hub'a eklemen gerekecek)
	players := g.getRoomPlayers(roomID)
	initialPlayerCount := len(players)

	if settings.TotalRounds < initialPlayerCount {
		settings.TotalRounds = initialPlayerCount
	}

	// Yeni oyun olu≈ütur

	newGame := &Game{
		RoomID:      roomID,
		ModeName:    settings.ModeName,
		ModeID:      settings.ModeID,
		State:       GameStateInProgress,
		Players:     players,
		TurnCount:   0,
		TotalRounds: settings.TotalRounds,
		//InitialPlayerCount: initialPlayerCount,
		PreparationDuration: settings.PreparationDuration,
		RoundDuration:       settings.RoundDuration,
		LastMoveTime:        time.Now(),
	}

	g.mutex.RLock()
	engine, engineExists := g.gameEngines[settings.ModeID]
	g.mutex.RUnlock()
	if !engineExists {
		fmt.Printf("Oyun motoru bulunamadƒ±: %v\n", settings)
		return
	}

	if err := engine.InitGame(newGame, players); err != nil {
		fmt.Printf("Oyun ba≈ülatƒ±lamadƒ±: %v\n", err)
		return
	}

	// Aktif oyunlar listesine ekle
	g.mutex.Lock()
	g.activeGames[roomID] = newGame
	if !settingsExists {
		g.roomSettings[roomID] = settings // üõë Ayar yoksa, onu da kaydet
	}
	g.mutex.Unlock()
	// Oyun ba≈üladƒ± mesajƒ±nƒ± t√ºm oyunculara g√∂nder
	response := &Message{
		Type: "game_started",
		Content: map[string]interface{}{
			"room_id":              roomID,
			"mode_name":            settings.ModeName,
			"mode_id":              settings.ModeName,
			"players":              g.playersToMap(players),
			"total_rounds":         newGame.TotalRounds,
			"round_duration":       newGame.RoundDuration,
			"initial_player_count": initialPlayerCount,
			"preparation_duration": newGame.PreparationDuration,
			"current_round":        1,
		},
	}
	g.hub.BroadcastMessage(roomID, response) // üí° ƒ∞LK MESAJ Gƒ∞TTƒ∞!

	go func(g *GameHub, engine IGameEngine, game *Game, roomID uuid.UUID) {
		preparationDuration := time.Duration(game.PreparationDuration) * time.Second

		game.Mutex.Lock()
		engine.SendPreparationNotifications(game)
		game.Mutex.Unlock()

		log.Printf("FIRST_ROUND_PREP: Waiting %v seconds before starting first round for room %s",
			game.PreparationDuration, roomID)

		// 2. HAZIRLIK S√úRESƒ∞ BEKLE
		time.Sleep(preparationDuration)

		// 4. ƒ∞LK TURU BA≈ûLAT
		// game.Mutex'i burada kullanabilirsiniz (StartRound'un i√ß yapƒ±sƒ±na baƒülƒ± olarak).
		game.Mutex.Lock() // Eƒüer StartRound game objesini deƒüi≈ütiriyorsa
		if err := engine.StartRound(game); err != nil {
			fmt.Printf("GOROUTINE: ƒ∞lk tur ba≈ülatƒ±lamadƒ±: %v\n", err)
		}
		game.Mutex.Unlock() // Eƒüer StartRound game objesini deƒüi≈ütiriyorsa

		// 5. ZAMANLAYICIYI BA≈ûLAT
		duration := time.Duration(game.RoundDuration) * time.Second
		// üí° Bu √ßaƒürƒ± RunListener'a sinyal g√∂ndereceƒüi i√ßin, oyun d√∂ng√ºs√º ba≈ülar.
		g.startRoundTimer(roomID, duration)

	}(g, engine, newGame, roomID)
	fmt.Printf("Oyun ba≈ülatƒ±ldƒ± - Room: %s, Mode: %s, Oyuncu Sayƒ±sƒ±: %d\n",
		roomID, settings.ModeName, len(players))
}

// getDefaultSettings, oyun moduna g√∂re varsayƒ±lan ayarlarƒ± d√∂ner
func (g *GameHub) getDefaultSettings(modeName string) *GameSettings {
	switch modeName {
	case "√áizim ve Tahmin":
		return &GameSettings{
			ModeName:            modeName,
			ModeID:              "1",
			TotalRounds:         2, // Her oyuncu 2 kez √ßizer
			RoundDuration:       60,
			MaxPlayers:          8,
			PreparationDuration: 5,
			MinPlayers:          2,
		}
	case "Ortak Alan":
		return &GameSettings{
			ModeName:            modeName,
			ModeID:              "2",
			TotalRounds:         1,
			RoundDuration:       120, //2 dakika
			PreparationDuration: 5,
			MaxPlayers:          10,
			MinPlayers:          2,
		}
	default:
		return &GameSettings{
			ModeName:            "√áizim ve Tahmin",
			TotalRounds:         2,
			RoundDuration:       60,
			PreparationDuration: 5,
			MaxPlayers:          8,
			MinPlayers:          2,
		}
	}
}

// calculateGameSettings, oda durumuna g√∂re ayarlarƒ± hesaplar
// func (g *GameHub) calculateGameSettings(roomID uuid.UUID, settings *GameSettings) {
// 	playerCount := g.hub.GetRoomClientCount(roomID)

// 	// √áizim ve Tahmin modunda her oyuncu √ßizecekse
// 	if settings.ModeName == "√áizim ve Tahmin" {
// 		// Her oyuncunun √ßizme fƒ±rsatƒ± olmasƒ± i√ßin round sayƒ±sƒ±nƒ± ayarla
// 		if playerCount > 0 {
// 			settings.TotalRounds = playerCount * 2 // Her oyuncu 2 kez √ßizer
// 		}
// 	}
// }

// getRoomPlayers, odadaki oyuncularƒ± Player yapƒ±sƒ±na d√∂n√º≈üt√ºr√ºr
func (g *GameHub) getRoomPlayers(roomID uuid.UUID) []*Player {

	// Hub'dan odadaki baƒülƒ± client'larƒ± al
	roomClients := g.hub.GetRoomClients(roomID)

	if len(roomClients) == 0 {
		return nil
	}

	var players []*Player

	// Hub'dan gelen her Client nesnesini bir Player nesnesine d√∂n√º≈üt√ºr
	for _, client := range roomClients {
		// NOT: Client nesnesinde sadece ID var.
		// Eƒüer Username/Kullanƒ±cƒ± Adƒ± bilgisini client nesnesinde veya veritabanƒ±nda tutuyorsanƒ±z,
		// onu kullanmalƒ±sƒ±nƒ±z.

		// Varsayƒ±m: `domain.Client` yapƒ±nƒ±zda `Username` alanƒ± var.
		// Eƒüer yoksa, ge√ßici olarak ID'yi veya veritabanƒ±ndan √ßekilen bilgiyi kullanƒ±n.

		username := fmt.Sprintf("User-%s", client.ID.String()[:4]) // Ge√ßici: ID'nin bir kƒ±smƒ±nƒ± kullan

		// Eƒüer `domain.Client` yapƒ±nƒ±zda kullanƒ±cƒ± adƒ± alanƒ± varsa:
		// username := client.Username // Burasƒ± domain.Client yapƒ±sƒ±na baƒülƒ±

		players = append(players, &Player{
			UserID:   client.ID,
			Username: username, // Ger√ßek kullanƒ±cƒ± adƒ±nƒ± buradan alƒ±n
			Score:    0,        // Yeni oyunda skor her zaman 0 ba≈ülar
		})
	}

	// Oyun ba≈ülama sƒ±rasƒ±nƒ± karƒ±≈ütƒ±rmak isterseniz burada karƒ±≈ütƒ±rma (shuffle) yapabilirsiniz.

	return players
}

// playersToMap, Player slice'ƒ±nƒ± map formatƒ±na d√∂n√º≈üt√ºr√ºr
func (g *GameHub) playersToMap(players []*Player) []map[string]interface{} {
	var result []map[string]interface{}

	for _, player := range players {
		result = append(result, map[string]interface{}{
			"user_id":  player.UserID,
			"username": player.Username,
			"score":    player.Score,
		})
	}

	return result
}

// IsGameActive, odada aktif oyun olup olmadƒ±ƒüƒ±nƒ± kontrol eder
func (g *GameHub) IsGameActive(roomID uuid.UUID) bool {
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	game, exists := g.activeGames[roomID]
	return exists && game.State == GameStateInProgress
}

// Diƒüer handler metodlarƒ± aynƒ± kalacak...
func (g *GameHub) handlePlayerMove(roomID uuid.UUID, msg RoomManagerData) {
	//g.mutex.RLock() // ActiveGames ve GameEngines'a eri≈ümek i√ßin
	g.mutex.RLock()
	game, exists := g.activeGames[roomID]

	if !exists {
		g.mutex.RUnlock() // üõë Erken √ßƒ±kƒ±≈üta kilidi bƒ±rak!
		log.Printf("PLAYER_MOVE_FAIL: Room %s, No active game found.", roomID)
		return
	}

	// 2. Artƒ±k 'game' objesi nil deƒüil. ModeID'yi g√ºvenle okuyabiliriz.
	engine, engineExists := g.gameEngines[game.ModeID]
	g.mutex.RUnlock() // üõë RLock bitti, ≈üimdi kilidi bƒ±

	if !engineExists || game.State != GameStateInProgress {
		log.Printf("PLAYER_MOVE_FAIL: Room %s, Game state: %s or engine missing.", roomID, game.State)
		return
	}

	// Mesajƒ±n i√ßeriƒüinden PlayerID'yi al
	moveData, ok := msg.Content.(map[string]interface{})
	if !ok {
		log.Printf("PLAYER_MOVE_FAIL: Invalid content format for room %s", roomID)
		return
	}

	playerIDStr, ok := moveData["player_id"].(string)
	if !ok {
		log.Printf("PLAYER_MOVE_FAIL: Player ID missing in message for room %s", roomID)
		return
	}

	playerID, err := uuid.Parse(playerIDStr)
	if err != nil {
		log.Printf("PLAYER_MOVE_FAIL: Invalid UUID format for room %s", roomID)
		return
	}
	fmt.Printf("Player %s made a move in room %s: %v\n", playerID, roomID, moveData)

	// // üéØ KRƒ∞Tƒ∞K ADIM: Hareketi oyun motoruna ilet
	if err := engine.ProcessMove(game, playerID, moveData); err != nil {
		log.Printf("PLAYER_MOVE_ERROR: %s, Error: %v", playerID, err)
		// Oyuncuya hata mesajƒ± g√∂nderebilirsiniz.
		// g.hub.SendMessageToUser(roomID, playerID, &Message{...})
		return
	}

	// ProcessMove ba≈üarƒ±lƒ± oldu, oyun durumu zaten yayƒ±nlanmƒ±≈ütƒ±r (DrawingGameEngine i√ßinde).
	log.Printf("Player %s's move processed successfully in room %s.", playerID, roomID)
	return

}

func (g *GameHub) handleEndGame(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Println("handleEndGame called for room", roomID)
	// Oyun bittiƒüinde roomSettings'i de temizle
	g.mutex.Lock()

	game, exists := g.activeGames[roomID]
	if !exists {
		g.mutex.Unlock()
		log.Printf("No active game to end for room %s", roomID)
		return
	}

	// Oyun durumunu g√ºncelle
	game.State = GameStateOver

	// Oyunu aktif oyunlardan ve ayarlardan kaldƒ±r
	delete(g.activeGames, roomID)
	//delete(g.roomSettings, roomID)

	g.mutex.Unlock()

	// Zamanlayƒ±cƒ±yƒ± durdur (mutex dƒ±≈üƒ±nda)
	g.stopRoundTimer(roomID)

	// Oyun biti≈ü mesajƒ±nƒ± yayƒ±nla
	content := msg.Content.(map[string]interface{})
	reason := content["reason"].(string)
	message := content["message"].(string)

	g.hub.BroadcastMessage(roomID, &Message{
		Type: "game_ended",
		Content: map[string]interface{}{
			"room_id": roomID,
			"reason":  reason,
			"message": message,
			"scores":  g.playersToMap(game.Players),
		},
	})

	log.Printf("Game ended for room %s. Reason: %s", roomID, reason)

	// Diƒüer i≈ülemler...
}

func (g *GameHub) handleDrawingData(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
	response := &Message{
		Type:    "drawing_data",
		Content: msg.Content,
	}

	g.hub.BroadcastMessage(roomID, response)
}

func (g *GameHub) handleGuessWord(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
}

func (g *GameHub) handleNextRound(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
}
