package hub

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/google/uuid"
)

// GameState, oyunun hangi a≈üamada olduƒüunu g√∂steren sabitler.
const (
	GameStateInProgress = "in_progress"
	GameStateOver       = "over"
)

// IGameEngine, t√ºm oyun motorlarƒ± i√ßin ortak bir aray√ºz tanƒ±mlar.
type IGameEngine interface {
	InitGame(game *Game, players []*Player) error
	ProcessMove(game *Game, playerID uuid.UUID, moveData interface{}) error
	CheckRoundStatus(game *Game) (bool, error)
	// Diƒüer oyun mantƒ±ƒüƒ± metotlarƒ± buraya eklenebilir.
}

// Player, oyundaki bir oyuncuyu temsil eder.
type Player struct {
	UserID   uuid.UUID
	Username string
	Score    int
	// Oyuncuya √∂zg√º diƒüer veriler
}

type GameSettings struct {
	ModeName      string `json:"mode_name"`
	ModeID        string `json:"mode_id"`
	TotalRounds   int    `json:"total_rounds"`
	RoundDuration int    `json:"round_duration"` // saniye cinsinden
	MaxPlayers    int    `json:"max_players"`
	MinPlayers    int    `json:"min_players"`
}

// Game, bir oyunun mevcut durumunu tutar.
type Game struct {
	RoomID             uuid.UUID   `json:"room_id"`
	ModeName           string      `json:"mode_name"`
	ModeID             string      `json:"mode_id"`
	State              string      `json:"state"`
	Players            []*Player   `json:"players"`
	TurnCount          int         `json:"turn_count"`
	TotalRounds        int         `json:"total_rounds"`
	RoundDuration      int         `json:"round_duration"`
	ActivePlayer       uuid.UUID   `json:"active_player"`
	LastMoveTime       time.Time   `json:"last_move_time"`
	ModeData           interface{} `json:"mode_data"`
	CurrentDrawerIndex int         `json:"current_drawer_index"`
	Mutex              sync.RWMutex
}

// Game'e √∂zel yapƒ±lar
type DrawingGameData struct {
	CurrentWord    string
	CurrentDrawer  uuid.UUID
	GuessedPlayers map[uuid.UUID]bool
	CanvasData     string
}

type CommonAreaGameData struct {
	CanvasData string
}

// GameHub, oyunun i≈ü mantƒ±ƒüƒ±ndan sorumludur.
type GameHub struct {
	hub *Hub
	// roomID -> game nesnesi
	activeGames map[uuid.UUID]*Game
	// gameModeName -> IGameEngine aray√ºz√º
	gameEngines     map[string]IGameEngine
	roomSettings    map[uuid.UUID]*GameSettings
	roundTimers     map[uuid.UUID]context.CancelFunc
	timerWaitGroups map[uuid.UUID]*sync.WaitGroup
	roundEndSignal  chan struct {
		RoomID uuid.UUID
		Reason string
	}

	mutex sync.RWMutex
}

func NewGameHub(hub *Hub) *GameHub {
	gameHub := &GameHub{
		hub:             hub,
		activeGames:     make(map[uuid.UUID]*Game),
		roomSettings:    make(map[uuid.UUID]*GameSettings),
		gameEngines:     make(map[string]IGameEngine),
		roundTimers:     make(map[uuid.UUID]context.CancelFunc),
		timerWaitGroups: make(map[uuid.UUID]*sync.WaitGroup),
		roundEndSignal: make(chan struct {
			RoomID uuid.UUID
			Reason string
		}, 5),
	}

	// gameHub.gameEngines["√áizim ve Tahmin"] = NewDrawingGameEngine(gameHub)
	gameHub.gameEngines["1"] = NewDrawingGameEngine(gameHub)
	// gameHub.gameEngines["Ortak Alan"] = NewDrawingGameEngine(gameHub)
	// gameHub.gameEngines["serbest √ßizim"] = NewDrawingGameEngine(gameHub)
	go gameHub.RunListener()
	return gameHub
}

func (g *GameHub) RunListener() {
	for {
		select {
		case quit := <-g.hub.playerQuit: // (√ñnceki i≈ülevsellik)
			g.HandlePlayerQuit(quit.RoomID, quit.UserID)

		// üí° YENƒ∞ CASE: Tur biti≈ü sinyalini i≈üle
		case endSignal := <-g.roundEndSignal:
			// Sinyal geldiƒüinde, G√úVENLƒ∞ bir ≈üekilde handleRoundEnd'i √ßaƒüƒ±r.
			// Bu zaten bir Gorutin i√ßinde olduƒüu i√ßin kilitlenme riski d√º≈ü√ºkt√ºr.
			log.Printf("RUN_LISTENER: Round end signal received for room %s. Reason: %s", endSignal.RoomID, endSignal.Reason)
			g.handleRoundEnd(endSignal.RoomID, endSignal.Reason)
		}
	}
}
func (g *GameHub) HandlePlayerQuit(roomID uuid.UUID, userID uuid.UUID) {
	g.mutex.Lock()
	defer g.mutex.Unlock()

	game, exists := g.activeGames[roomID]
	if !exists || game.State != GameStateInProgress {
		return // Oyun devam etmiyorsa bir ≈üey yapma
	}

	// Oyuncu listesinden √ßƒ±kar
	newPlayers := make([]*Player, 0, len(game.Players)-1)
	playerFound := false
	for _, p := range game.Players {
		if p.UserID == userID {
			playerFound = true
			continue
		}
		newPlayers = append(newPlayers, p)
	}

	if !playerFound {
		return // Oyuncu zaten listede yoksa
	}

	game.Players = newPlayers

	// Kalan oyuncu sayƒ±sƒ±nƒ± kontrol et
	settings, _ := g.roomSettings[roomID]
	if len(game.Players) < settings.MinPlayers {
		// üí° Yetersiz oyuncu sayƒ±sƒ±, oyunu bitir.
		msg := RoomManagerData{
			Type: "end_game",
			Content: map[string]interface{}{
				"reason": "insufficient_players",
			},
		}
		g.handleEndGame(roomID, msg)
		return
	}

	// Sƒ±rasƒ± gelen oyuncu mu ayrƒ±ldƒ±?
	if game.ActivePlayer == userID {
		log.Printf("Current drawer %s has left the game.", userID)
		// üí° Turu hemen bitir ve yeni tura ge√ß
		g.handleRoundEnd(roomID, "drawer_left")
		return
	}

	// Oyun devam ediyor, oyunculara bildirim g√∂nder
	g.hub.BroadcastMessage(roomID, &Message{
		Type: "player_left",
		Content: map[string]interface{}{
			"room_id": roomID,
			"user_id": userID,
		},
	})
}
func (g *GameHub) startRoundTimer(roomID uuid.UUID, duration time.Duration) {
	// √ñnceki zamanlayƒ±cƒ± varsa durdur ve bekle (Bloklama burada oluyor)
	g.stopRoundTimer(roomID)

	// Yeni zamanlayƒ±cƒ± i√ßin hazƒ±rlƒ±k
	wg := &sync.WaitGroup{}
	wg.Add(1)

	// üí° DEƒûƒ∞≈ûƒ∞KLƒ∞K: context.WithCancel yerine context.WithTimeout kullanƒ±n!
	ctx, cancel := context.WithTimeout(context.Background(), duration)

	// Haritalara kaydet
	g.mutex.Lock()
	g.roundTimers[roomID] = cancel
	g.timerWaitGroups[roomID] = wg
	g.mutex.Unlock()
	log.Printf("START_TIMER: Goroutine started for room %s, duration: %v", roomID, duration)
	go func() {
		defer wg.Done() // Gorutin i≈üini bitirdiƒüinde sayacƒ± azalt.

		select {
		case <-ctx.Done():
			// Context, ya s√ºre dolduƒüu i√ßin (Timeout) ya da manuel iptal (Cancel)
			// nedeniyle kapandƒ±.
			log.Printf("TIMER_GOROUTINE: Context closed for room %s. Error: %v", roomID, ctx.Err())
			// üí° Kontrol: S√ºre mi doldu, yoksa iptal mi edildi?
			if ctx.Err() == context.DeadlineExceeded {
				g.roundEndSignal <- struct {
					RoomID uuid.UUID
					Reason string
				}{
					RoomID: roomID,
					Reason: "time_expired",
				}
			}
			// (context.Canceled ise, manuel bitmi≈ütir ve bu zaten EndRound'ƒ± tetiklemi≈ütir.)
			return
		}
	}()
}

// package hub
func (g *GameHub) stopRoundTimer(roomID uuid.UUID) {
	var cancelFunc context.CancelFunc
	var wg *sync.WaitGroup
	var cancelExists, wgExists bool

	// 1. Lock/Unlock ve Haritalardan Kaldƒ±rma
	g.mutex.Lock()
	cancelFunc, cancelExists = g.roundTimers[roomID]
	wg, wgExists = g.timerWaitGroups[roomID]

	delete(g.roundTimers, roomID)
	delete(g.timerWaitGroups, roomID)
	g.mutex.Unlock() // Kilit serbest bƒ±rakƒ±ldƒ±.

	// 2. ƒ∞ptal Sinyalini G√∂nder
	if cancelExists {
		cancelFunc()
		log.Printf("STOP_TIMER: Cancel signal sent for room %s.", roomID)
	}

	// 3. Goroutine'in Bitmesini G√úVENLƒ∞ Bƒ∞R ≈ûEKƒ∞LDE Bekle (Zaman A≈üƒ±mƒ±)
	if wgExists {
		done := make(chan struct{})

		// Goroutine'i bekleyen AYRI bir Goroutine ba≈ülat
		go func() {
			// √ñNEMLƒ∞: Eƒüer timer Goroutine'de birden fazla wg.Done() varsa
			// veya hi√ß yoksa, bu kilitlenir. Ancak timeout bunu √ß√∂zer.
			wg.Wait()
			close(done)
		}()

		// Zaman a≈üƒ±mƒ± ile bekle
		select {
		case <-done:
			// Ba≈üarƒ±lƒ±: Goroutine sonlandƒ±.
			log.Printf("STOP_TIMER: Old timer for %s safely stopped.", roomID)
		case <-time.After(500 * time.Millisecond): // 0.5 saniye yeterli olmalƒ±
			// Zaman A≈üƒ±mƒ±: 0.5 saniye i√ßinde sonlanmadƒ±, ancak devam et.
			log.Printf("STOP_TIMER: WARNING: Old timer for %s did not terminate in 500ms. Continuing.", roomID)
		}
	}
}

func (g *GameHub) handleRoundEnd(roomID uuid.UUID, reason string) {
	// 1. En √ºst seviye kilit: GameHub'ƒ± kilitliyoruz.

	log.Printf("HANDLE_ROUND_END: Starting round end process for room %s. Reason: %s", roomID, reason)
	// 2. Zamanlayƒ±cƒ±yƒ± hemen durdur.
	g.stopRoundTimer(roomID)
	g.mutex.Lock()
	defer g.mutex.Unlock()
	fmt.Println("Round timer stopped for room", roomID)

	game, exists := g.activeGames[roomID]
	if !exists {
		return // Oyun zaten bitmi≈ü olabilir
	}
	log.Printf("Round ended for room %s. Reason: %s", roomID, reason)

	engine, ok := g.gameEngines[game.ModeID]
	if !ok {
		log.Printf("Game engine not found for mode: %s", game.ModeID)
		return
	}
	dge, _ := engine.(*DrawingGameEngine)
	log.Printf("HANDLE_ROUND_END: Attempting to acquire game.Mutex for room %s.", roomID)
	// 3. Oyun durumunu g√ºncellemek i√ßin Game kilidini alƒ±yoruz.
	game.Mutex.Lock()

	// dge.EndRound metodu, puanlama ve tur/oyun biti≈ü kontrol√ºn√º yapar.
	// Artƒ±k bu metodun i√ßinde kilit yok.
	shouldContinue := dge.EndRound(game, reason)

	// Game kilidini serbest bƒ±rak (√ßok √∂nemli!).
	game.Mutex.Unlock()
	log.Printf("HANDLE_ROUND_END: EndRound finished for room %s. Should continue: %v", roomID, shouldContinue)

	// 4. Her tur bittiƒüinde oyunculara genel bir "tur bitti" mesajƒ± yayƒ±nla.
	g.hub.BroadcastMessage(roomID, &Message{
		Type: "round_ended",
		Content: map[string]interface{}{
			"room_id": roomID,
			"reason":  reason,
			"game":    game, // G√ºncel oyun durumunu g√∂nder
		},
	})

	// 5. Bir sonraki tura ge√ßilecek mi, yoksa oyun mu bitecek kararƒ±nƒ± ver.
	if shouldContinue {
		// Yeni tur varsa:
		log.Printf("NEXT_ROUND: Starting in background for room %s.", roomID)
		// Yeniden Game kilidini alƒ±yoruz, √ß√ºnk√º StartRound oyun nesnesini deƒüi≈ütirecek.
		// ‚ö†Ô∏è KRƒ∞Tƒ∞K DEƒûƒ∞≈ûƒ∞KLƒ∞K: StartRound ve Timer'ƒ± yeni bir Goroutine'e ta≈üƒ±!
		go func(g *GameHub, dge *DrawingGameEngine, game *Game, roomID uuid.UUID) {

			// Yeni turu ba≈ülat (Game kilidi GOROUTINE i√ßinde alƒ±nmalƒ±!)
			game.Mutex.Lock()

			if err := dge.StartRound(game); err != nil {
				log.Printf("GOROUTINE ERROR: Error starting next round: %v", err)
			}

			game.Mutex.Unlock()

			// Yeni tur zamanlayƒ±cƒ±sƒ±nƒ± ba≈ülat.
			duration := time.Duration(game.RoundDuration) * time.Second
			g.startRoundTimer(roomID, duration)

		}(g, dge, game, roomID) // Deƒüi≈ükenleri Goroutine'e ge√ßir.

		log.Printf("NEXT_ROUND: Starting in background for room %s.", roomID)

	} else {
		// Oyun bittiyse:
		log.Printf("GAME_OVER: Game finished for room %s. Total Rounds: %d", roomID, game.TotalRounds)
		// Oyun Bitti mesajƒ±nƒ± yayƒ±nla.
		g.hub.BroadcastMessage(game.RoomID, &Message{
			Type: "game_over",
			Content: map[string]interface{}{
				"scores": game.Players,
				"winner": dge.determineWinner(game),
			},
		})

		// Aktif oyunlardan kaldƒ±r.
		delete(g.activeGames, roomID)
		delete(g.roomSettings, roomID)
	}
}
func (g *GameHub) HandleGameMessage(roomID uuid.UUID, msg RoomManagerData) {
	g.mutex.Lock()
	defer g.mutex.Unlock()

	fmt.Println("GameHub'da gelen mesaj:", msg.Type, "RoomID:", roomID)

	switch msg.Type {
	case "game_mode_change":
		g.handleGameModeChange(roomID, msg)
	case "game_settings_update":
		g.handleGameSettingsUpdate(roomID, msg)
	case "game_started":
		g.handleGameStarted(roomID, msg)
	// case "player_move":
	// 	g.handlePlayerMove(roomID, msg)
	// case "end_game":
	// 	g.handleEndGame(roomID, msg)
	// case "drawing_data":
	// 	g.handleDrawingData(roomID, msg)
	// case "guess_word":
	// 	g.handleGuessWord(roomID, msg)
	// case "next_round":
	// 	g.handleNextRound(roomID, msg)
	default:
		fmt.Printf("GameHub: Bilinmeyen mesaj tipi: %s\n", msg.Type)
	}
}

// handleGameModeChange, oyun modu deƒüi≈üikliƒüini i≈üler
func (g *GameHub) handleGameModeChange(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun modu deƒüi≈üikliƒüi - Room: %s\n", roomID)

	modeData, ok := msg.Content.(map[string]interface{})
	if !ok {
		fmt.Println("Game mode verisi parse edilemedi")
		return
	}
	fmt.Printf("Oyun modu deƒüi≈üikliƒüi - data : %s\n", modeData)

	modeID, ok := modeData["mode_id"].(string)
	if !ok {
		fmt.Println("Mode id  bulunamadƒ±")
		return
	}

	// Oyun motoru var mƒ± kontrol et
	if _, exists := g.gameEngines[modeID]; !exists {
		fmt.Printf("Desteklenmeyen oyun modu: %s\n", modeID)
		return
	}

	// Odanƒ±n ayarlarƒ±nƒ± al veya olu≈ütur
	settings, exists := g.roomSettings[roomID]
	if !exists {
		settings = g.getDefaultSettings(modeID)
	} else {
		settings.ModeID = modeID
		// Mode deƒüi≈ütiƒüinde ayarlarƒ± yeniden hesapla
		g.calculateGameSettings(roomID, settings)
	}

	g.roomSettings[roomID] = settings

	// Oyun modu deƒüi≈üikliƒüini odadaki herkese bildir
	response := &Message{
		Type: "game_mode_changed",
		Content: map[string]interface{}{
			"room_id":  roomID,
			"mode_id":  modeID,
			"settings": settings,
		},
	}

	g.hub.BroadcastMessage(roomID, response)
	fmt.Printf("Oyun modu deƒüi≈ütirildi - Room: %s, Mode: %s\n", roomID, modeID)
}

// handleGameSettingsUpdate, oyun ayarlarƒ± g√ºncellemesini i≈üler
func (g *GameHub) handleGameSettingsUpdate(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun ayarlarƒ± g√ºncelleniyor - Room: %s\n", roomID)

	settingsData, ok := msg.Content.(map[string]interface{})
	if !ok {
		fmt.Println("Settings verisi parse edilemedi")
		return
	}

	settings, exists := g.roomSettings[roomID]
	if !exists {
		// Varsayƒ±lan ayarlarƒ± olu≈ütur
		settings = &GameSettings{
			ModeName:      "√áizim ve Tahmin", // default
			TotalRounds:   2,
			RoundDuration: 60,
			MaxPlayers:    8,
			MinPlayers:    2,
		}
	}

	// Ayarlarƒ± g√ºncelle
	if rounds, ok := settingsData["total_rounds"].(float64); ok {
		settings.TotalRounds = int(rounds)
	}
	if duration, ok := settingsData["round_duration"].(float64); ok {
		settings.RoundDuration = int(duration)
	}
	if maxPlayers, ok := settingsData["max_players"].(float64); ok {
		settings.MaxPlayers = int(maxPlayers)
	}
	if minPlayers, ok := settingsData["min_players"].(float64); ok {
		settings.MinPlayers = int(minPlayers)
	}

	g.roomSettings[roomID] = settings

	// Ayar g√ºncellemesini bildir
	response := &Message{
		Type: "game_settings_updated",
		Content: map[string]interface{}{
			"room_id":  roomID,
			"settings": settings,
		},
	}

	g.hub.BroadcastMessage(roomID, response)
	fmt.Printf("Oyun ayarlarƒ± g√ºncellendi - Room: %s\n", roomID)
}

// handleGameStarted, oyun ba≈ülatƒ±ldƒ±ƒüƒ±nda √ßaƒürƒ±lƒ±r
func (g *GameHub) handleGameStarted(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Printf("Oyun ba≈ülatƒ±lƒ±yor - Room: %s\n", roomID)
	// g.mutex.Lock()
	// defer g.mutex.Unlock()

	if game, exists := g.activeGames[roomID]; exists && game.State == GameStateInProgress {
		fmt.Printf("Oyun zaten devam ediyor. Yeni oyun ba≈ülatma isteƒüi reddedildi - Room: %s\n", roomID)
		// Oyunculara hata mesajƒ± g√∂nder
		g.hub.BroadcastMessage(roomID, &Message{
			Type: "game_start_failed",
			Content: map[string]interface{}{
				"room_id": roomID,
				"reason":  "game_already_in_progress",
				"message": "Bu odada zaten bir oyun devam ediyor.",
			},
		})
		return
	}

	// Odanƒ±n ayarlarƒ±nƒ± kontrol et
	settings, exists := g.roomSettings[roomID]
	if !exists {
		fmt.Printf("Oda ayarlarƒ± bulunamadƒ±, varsayƒ±lan ayarlar kullanƒ±lƒ±yor - Room: %s\n", roomID)
		settings = g.getDefaultSettings("√áizim ve Tahmin")
		g.roomSettings[roomID] = settings
	}

	// Odadaki oyuncu sayƒ±sƒ±nƒ± kontrol et
	playerCount := g.hub.GetRoomClientCount(roomID)
	if playerCount < settings.MinPlayers {
		fmt.Printf("Yetersiz oyuncu sayƒ±sƒ± - Room: %s, Mevcut: %d, Minimum: %d\n",
			roomID, playerCount, settings.MinPlayers)

		// Yetersiz oyuncu mesajƒ± g√∂nder
		response := &Message{
			Type: "game_start_failed",
			Content: map[string]interface{}{
				"room_id": roomID,
				"reason":  "insufficient_players",
				"message": fmt.Sprintf("Minimum %d oyuncu gerekli", settings.MinPlayers),
			},
		}
		g.hub.BroadcastMessage(roomID, response)
		return
	}

	// Odadaki oyuncularƒ± al (Bu fonksiyonu Hub'a eklemen gerekecek)
	players := g.getRoomPlayers(roomID)

	// Yeni oyun olu≈ütur
	game := &Game{
		RoomID:        roomID,
		ModeName:      settings.ModeName,
		ModeID:        settings.ModeID,
		State:         GameStateInProgress,
		Players:       players,
		TurnCount:     0,
		TotalRounds:   settings.TotalRounds,
		RoundDuration: settings.RoundDuration,
		LastMoveTime:  time.Now(),
	}

	// Oyun motorunu al ve oyunu ba≈ülat
	engine, exists := g.gameEngines[settings.ModeID]
	if !exists {
		fmt.Printf("Oyun motoru bulunamadƒ±: %s\n", settings.ModeID)
		return
	}
	dge, _ := engine.(*DrawingGameEngine)
	if err := dge.InitGame(game, players); err != nil {
		fmt.Printf("Oyun ba≈ülatƒ±lamadƒ±: %v\n", err)
		return
	}

	// Aktif oyunlar listesine ekle
	g.activeGames[roomID] = game

	// Oyun ba≈üladƒ± mesajƒ±nƒ± t√ºm oyunculara g√∂nder
	response := &Message{
		Type: "game_started",
		Content: map[string]interface{}{
			"room_id":        roomID,
			"mode_name":      settings.ModeName,
			"mode_id":        settings.ModeName,
			"players":        g.playersToMap(players),
			"total_rounds":   game.TotalRounds,
			"round_duration": game.RoundDuration,
			"current_round":  1,
		},
	}
	g.hub.BroadcastMessage(roomID, response) // üí° ƒ∞LK MESAJ Gƒ∞TTƒ∞!

	go func(g *GameHub, dge *DrawingGameEngine, game *Game, roomID uuid.UUID) {
		// 4. ƒ∞LK TURU BA≈ûLAT
		// game.Mutex'i burada kullanabilirsiniz (StartRound'un i√ß yapƒ±sƒ±na baƒülƒ± olarak).
		// game.Mutex.Lock() // Eƒüer StartRound game objesini deƒüi≈ütiriyorsa
		if err := dge.StartRound(game); err != nil {
			fmt.Printf("GOROUTINE: ƒ∞lk tur ba≈ülatƒ±lamadƒ±: %v\n", err)
		}
		// game.Mutex.Unlock() // Eƒüer StartRound game objesini deƒüi≈ütiriyorsa

		// 5. ZAMANLAYICIYI BA≈ûLAT
		duration := time.Duration(game.RoundDuration) * time.Second
		// üí° Bu √ßaƒürƒ± RunListener'a sinyal g√∂ndereceƒüi i√ßin, oyun d√∂ng√ºs√º ba≈ülar.
		g.startRoundTimer(roomID, duration)

	}(g, dge, game, roomID)
	fmt.Printf("Oyun ba≈ülatƒ±ldƒ± - Room: %s, Mode: %s, Oyuncu Sayƒ±sƒ±: %d\n",
		roomID, settings.ModeName, len(players))
}

// getDefaultSettings, oyun moduna g√∂re varsayƒ±lan ayarlarƒ± d√∂ner
func (g *GameHub) getDefaultSettings(modeName string) *GameSettings {
	switch modeName {
	case "√áizim ve Tahmin":
		return &GameSettings{
			ModeName:      modeName,
			ModeID:        "1",
			TotalRounds:   2, // Her oyuncu 2 kez √ßizer
			RoundDuration: 60,
			MaxPlayers:    8,
			MinPlayers:    2,
		}
	case "Ortak Alan":
		return &GameSettings{
			ModeName:      modeName,
			ModeID:        "2",
			TotalRounds:   1,
			RoundDuration: 120, //2 dakika
			MaxPlayers:    10,
			MinPlayers:    2,
		}
	default:
		return &GameSettings{
			ModeName:      "√áizim ve Tahmin",
			TotalRounds:   2,
			RoundDuration: 60,
			MaxPlayers:    8,
			MinPlayers:    2,
		}
	}
}

// calculateGameSettings, oda durumuna g√∂re ayarlarƒ± hesaplar
func (g *GameHub) calculateGameSettings(roomID uuid.UUID, settings *GameSettings) {
	playerCount := g.hub.GetRoomClientCount(roomID)

	// √áizim ve Tahmin modunda her oyuncu √ßizecekse
	if settings.ModeName == "√áizim ve Tahmin" {
		// Her oyuncunun √ßizme fƒ±rsatƒ± olmasƒ± i√ßin round sayƒ±sƒ±nƒ± ayarla
		if playerCount > 0 {
			settings.TotalRounds = playerCount * 2 // Her oyuncu 2 kez √ßizer
		}
	}
}

// getRoomPlayers, odadaki oyuncularƒ± Player yapƒ±sƒ±na d√∂n√º≈üt√ºr√ºr
func (g *GameHub) getRoomPlayers(roomID uuid.UUID) []*Player {

	// Hub'dan odadaki baƒülƒ± client'larƒ± al
	roomClients := g.hub.GetRoomClients(roomID)

	if len(roomClients) == 0 {
		return nil
	}

	var players []*Player

	// Hub'dan gelen her Client nesnesini bir Player nesnesine d√∂n√º≈üt√ºr
	for _, client := range roomClients {
		// NOT: Client nesnesinde sadece ID var.
		// Eƒüer Username/Kullanƒ±cƒ± Adƒ± bilgisini client nesnesinde veya veritabanƒ±nda tutuyorsanƒ±z,
		// onu kullanmalƒ±sƒ±nƒ±z.

		// Varsayƒ±m: `domain.Client` yapƒ±nƒ±zda `Username` alanƒ± var.
		// Eƒüer yoksa, ge√ßici olarak ID'yi veya veritabanƒ±ndan √ßekilen bilgiyi kullanƒ±n.

		username := fmt.Sprintf("User-%s", client.ID.String()[:4]) // Ge√ßici: ID'nin bir kƒ±smƒ±nƒ± kullan

		// Eƒüer `domain.Client` yapƒ±nƒ±zda kullanƒ±cƒ± adƒ± alanƒ± varsa:
		// username := client.Username // Burasƒ± domain.Client yapƒ±sƒ±na baƒülƒ±

		players = append(players, &Player{
			UserID:   client.ID,
			Username: username, // Ger√ßek kullanƒ±cƒ± adƒ±nƒ± buradan alƒ±n
			Score:    0,        // Yeni oyunda skor her zaman 0 ba≈ülar
		})
	}

	// Oyun ba≈ülama sƒ±rasƒ±nƒ± karƒ±≈ütƒ±rmak isterseniz burada karƒ±≈ütƒ±rma (shuffle) yapabilirsiniz.

	return players
}

// playersToMap, Player slice'ƒ±nƒ± map formatƒ±na d√∂n√º≈üt√ºr√ºr
func (g *GameHub) playersToMap(players []*Player) []map[string]interface{} {
	var result []map[string]interface{}

	for _, player := range players {
		result = append(result, map[string]interface{}{
			"user_id":  player.UserID,
			"username": player.Username,
			"score":    player.Score,
		})
	}

	return result
}

// IsGameActive, odada aktif oyun olup olmadƒ±ƒüƒ±nƒ± kontrol eder
func (g *GameHub) IsGameActive(roomID uuid.UUID) bool {
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	game, exists := g.activeGames[roomID]
	return exists && game.State == GameStateInProgress
}

// Diƒüer handler metodlarƒ± aynƒ± kalacak...
func (g *GameHub) handlePlayerMove(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
}

func (g *GameHub) handleEndGame(roomID uuid.UUID, msg RoomManagerData) {
	fmt.Println("handleEndGame called for room", roomID)
	// Oyun bittiƒüinde roomSettings'i de temizle
	delete(g.activeGames, roomID)
	delete(g.roomSettings, roomID)

	// Diƒüer i≈ülemler...
}

func (g *GameHub) handleDrawingData(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
	response := &Message{
		Type:    "drawing_data",
		Content: msg.Content,
	}

	g.hub.BroadcastMessage(roomID, response)
}

func (g *GameHub) handleGuessWord(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
}

func (g *GameHub) handleNextRound(roomID uuid.UUID, msg RoomManagerData) {
	// √ñnceki implementation aynƒ±
}
